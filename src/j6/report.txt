学籍番号: 2210342
氏名: 鈴木謙太郎
---

# 問題1

## 1.1
式: (apple orange pear grapefruit)
解答: (car(cdr(cdr '(apple orange pear grapefruit))))
解答(合成): (caddr '(apple orange pear grapefruit))

## 1.2
式: ((apple orange) (pear grapefruit))
解答: (car(car(cdr '((apple orange) (pear grapefruit)))))
解答(合成): (caadr '((apple orange) (pear grapefruit)))

## 1.3
式: (((apple) (orange) (pear) (grapefruit)))
解答: (car(car(cdr(cdr(car '(((apple) (orange) (pear) (grapefruit))))))))
解答(合成): (car (caddar '(((apple) (orange) (pear) (grapefruit))))) ;PEARだけを含むリストを取り出すまでと、そこからPEARを取り出すまでを分けている

## 1.4
式: (apple (orange) ((pear)) (((grapefruit))))
解答: (car(car(car(cdr(cdr(car '((apple (orange) ((pear)) (((grapefruit)))))))))))
解答(合成): (caar (caddar '((apple (orange) ((pear)) (((grapefruit))))))) ;PEARだけを含むリストを取り出すまでと、そこからPEARを取り出すまでを分けている

## 1.5
式: ((((apple))) ((orange)) (pear) grapefruit)
解答: (car(car(cdr(cdr '((((apple))) ((orange)) (pear) grapefruit)))))
解答(合成): (car (caddr '((((apple))) ((orange)) (pear) grapefruit))) ;PEARだけを含むリストを取り出すまでと、そこからPEARを取り出すまでを分けている

## 1.6
式: ((((apple) orange) pear) grapefruit)
解答: (car(cdr(car '((((apple) orange) pear) grapefruit))))
解答(合成): (cadar '((((apple) orange) pear) grapefruit))

---

# 問題2

1行目でtoolsに['hammer', 'screwdriver']を代入している。
2行目でtoolsの先頭に'pliers'を追加しているが、consは非破壊的な操作であるため、3行目で出力させたtoolsの値は変わらない。
4行目では2行目と同じconsの結果をtoolsに再代入しているので、5行目では変更後のtoolsの値が出力される。

6行目以降のappendにおいても同様であり、これは非破壊的な操作であるため明示的にtoolsに結果を再代入しないとtoolsの値は変わらない。

```clisp
[1]> (set 'tools (list 'hammer 'screwdriver))
(cons 'pliers tools)
tools
(set 'tools (cons 'pliers tools))
tools
(append '(saw wrench) tools)
tools
(set 'tools (append '(saw wrench) tools))
tools
(HAMMER SCREWDRIVER)
[2]>
(PLIERS HAMMER SCREWDRIVER)
[3]>
(HAMMER SCREWDRIVER)
[4]>
(PLIERS HAMMER SCREWDRIVER)
[5]>
(PLIERS HAMMER SCREWDRIVER)
[6]>
(SAW WRENCH PLIERS HAMMER SCREWDRIVER)
[7]>
(PLIERS HAMMER SCREWDRIVER)
[8]>
(SAW WRENCH PLIERS HAMMER SCREWDRIVER)
[9]>
(SAW WRENCH PLIERS HAMMER SCREWDRIVER)
```

---

# 問題3

lengthは引数に与えられたリストの直下の子要素を数える。
そのため、(plato socrates aristotle)は3つの要素を持つリストであるため、3が返される。
((plato) (socrates) (aristotle))は3つのリストを要素とするリストであるため、3が返される。
((plato socrates aristotle))は3つの要素を持つ1つのリストを要素とするリストであるため、1が返される。


```clisp
[1]> (length '(plato socrates aristotle))
3
[2]> (length '((plato) (socrates) (aristotle)))
3
[3]> (length '((plato socrates aristotle)))
1
```

3行目で与えられたリストから3の出力を得たければ、次のようになるだろう。

```clisp
[4]> (length (car '((plato socrates aristotle))))
3
```

---

# 問題4

問題3と同様の構造のデータである。
reverseは引数に与えられたリストの直下の子要素を逆順に並べたリストを返す。

(plato socrates aristotle)は3つの要素を持つリストであるため、(aristotle socrates plato)が返される。
((plato) (socrates) (aristotle))は3つのリストを要素とするリストであるため、(aristotle socrates plato)が返される。
((plato socrates aristotle))は3つの要素を持つ1つのリストを要素とするリストであるため、((plato socrates aristotle))が返される。


```clisp
[1]> (reverse '(plato socrates aristotle))
(ARISTOTLE SOCRATES PLATO)
[2]> (reverse '((plato) (socrates) (aristotle)))
((ARISTOTLE) (SOCRATES) (PLATO))
[3]> (reverse '((plato socrates aristotle)))
((PLATO SOCRATES ARISTOTLE))
```

3行目で与えられたリストから((ARISTOTLE SOCRATES PLATO))の出力を得たければ、次のようになるだろう。

```clisp
[4]> (list (reverse (car '((plato socrates aristotle)))))
((ARISTOTLE SOCRATES PLATO))
```

---

# 問題5

appendは2つのリストを結合するので、appendに要素数2のリスト, 要素数2のリストを与えると、要素数4のリストが返される。

substはリストの中から指定された要素を探し、指定された要素に置き換える。


```clisp
[1]> (length '((car chevrolet) (drink coke) (cereal wheaties)))
3
[2]> (reverse '((car chevrolet) (drink coke) (cereal wheaties)))
((CEREAL WHEATIES) (DRINK COKE) (CAR CHEVROLET))
[3]> (append '((car chevrolet) (drink coke)) (reverse '((car chevrolet) (drink coke))))
((CAR CHEVROLET) (DRINK COKE) (DRINK COKE) (CAR CHEVROLET))
[4]> (subst 'out 'in '(the ball is in))
(THE BALL IS OUT)
[5]> (subst 'in 'out '(the ball is in))
(THE BALL IS IN)
[6]> (last '(the ball is in))
(IN)
```

ところで、プログラミング言語によっては文字列を文字のリストとして扱っている場合がある。
その場合文字列にsubstを適用すると、文字列の中から指定された文字を探し、指定された文字に置き換えることになる。
実際に動くのか試した。

```bash
[7]> (subst 'a 'b 'abc)
ABC
```

substは文字列に対して適用できなかった。

---

# 問題6

以下のような関数を定義した。
second1やthird1のような操作を行う関数から呼び出されることを想定し、引数が空リストの場合の処理を行っている。

```lisp
(defun first1 (list) (
    if (null list) nil
    (car list)
))
(defun rest1 (list) (
    if (null list) nil
    (cdr list)
))
(defun insert (elm list)
    (if (null list) (cons elm nil)
    (cons elm list)))

(defun second1 (list) (first1 (rest1 list)))
(defun third1 (list) (first1 (rest1 (rest1 list))))
```

---

# 問題7

以下のような関数を定義した。
rest関数を使って先頭要素以外を取り出し、carで取り出した先頭要素をリストにして両者を結合することで実現した。

```lisp
(defun rotate-1 (ary)
    (append (rest ary) (list(car ary))))
```

---

# 問題8

以下のような関数を定義した。
引数で与えられたリストとその逆順リストを結合することで実現した。

```lisp
(defun palindrome (ary)
  (append ary (reverse ary)))
```

---

# 問題9

以下のような関数を定義した。
回分の定義を考えると、引数で与えられたリストとその逆順リストが等しいかどうかを判定すればよい。

```lisp
(defun palindromep (list)
  (equal list (reverse list)))
```

---

# 問題10

以下のような関数を定義した。

```lisp
(defun check-temperture (temp)
  (cond ((> temp 100) 'RIDICULOUSLY-HOT)
        ((< temp 0) 'RIDICULOUSLY-COLD)
        (t 'OK)))
```

出力は以下のようであり、仕様を満たしている。

```bash
[1]> (check-temperture 100)
OK
[2]> (check-temperture 101)
RIDICULOUSLY-HOT
[3]> (check-temperture 0)
OK
[4]> (check-temperture -1)
RIDICULOUSLY-COLD
[5]> (check-temperture 50)
OK
```

---

# 問題11

以下のような関数を定義した。
配列の長さが1であればそのまま返し、そうでなければ先頭要素を最後尾に移動させ、残りの要素に対して再帰的に処理を行う。

condを用いるより簡潔に書けると判断したためifを用いた。

```lisp
(defun my-reverse (ary)
  (if (equalp (length ary) 1)
    ary
    (append (my-reverse (cdr ary)) (list (car ary)))
  ))
```

また、入れ子になっているリストをすべて逆順にする以下のような関数も定義した。

```lisp
(defun al-reverse (ary)
  (if (equalp (length ary) 1)
    ary
    (append (al-reverse (cdr ary)) (list (if (listp (car ary)) (al-reverse (car ary)) (car ary)))
    )))
```

my-reverseにおいて、先頭要素を末尾に移動させる際にそれがリストであれば、そのリストに対しても逆順にする処理を行うことで、入れ子になっているリストをすべて逆順にすることができる。

---

# 問題12
